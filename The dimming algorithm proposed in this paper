  % 读取图像
img = imread('F:\test\low\pic (11).jpg');
img_sal=imread('F:\test\low_sal\pic (11).png');     % 读取显著性排序图

% Extract the RGB channels
% Extract the RGB channels
r = img(:, :, 1);
g = img(:, :, 2);
b = img(:, :, 3);
gray=zeros(1080,1920);
for i=1:1080
    for j=1:1920
        gray(i,j)=max(max(r(i,j),g(i,j)),b(i,j));
    end
end    %提取子像素最大值亮度矩阵

V=mat2cell(gray,[repelem(40, 27)],[repmat(40, 1, 48)]);
X=cellfun(@max,cellfun(@max,V,'UniformOutput',false));  %求每块初始背光
X=double(X);

% 获取原始图像的尺寸
[height, width, ~] = size(img);

% 定义每个分区的大小
partitionWidth = 40;
partitionHeight = 40;

% 计算分区的行数和列数
numRows = floor(height / partitionHeight);
numCols = floor(width / partitionWidth);

% 初始化一个存储分区的单元格数组
imagePartitions = cell(numRows, numCols);

% 切分图像并存储每个分区
for i = 1:numRows
    for j = 1:numCols
        % 计算每个分区的位置
        startX = (j - 1) * partitionWidth + 1;
        startY = (i - 1) * partitionHeight + 1;

        % 提取分区
        partition = img(startY:startY + partitionHeight - 1, startX:startX + partitionWidth - 1, :);

        % 存储分区
        imagePartitions{i, j} = partition;
    end
end

%加权权重确定
S=rgb2gray(img_sal);
S_max=double(max(S(:)));
S = double(S);
S_normal=S./S_max;
% 判定背景的像素个数和占比

S_T=40.*S_normal;
num_back=sum(S(:) == 0);
n_back=num_back/(1920 * 1080);
S_T(S_T == 0) =n_back;

% 初始化一个存储分区的单元格数组
imagePartitions1 = cell(numRows, numCols);

% 切分图像并存储每个分区
for i = 1:numRows
    for j = 1:numCols
        % 计算每个分区的位置
        startX1 = (j - 1) * partitionWidth + 1;
        startY1 = (i - 1) * partitionHeight + 1;

        % 提取分区
        partition1 = S_T(startY1:startY1 + partitionHeight - 1, startX1:startX1 + partitionWidth - 1, :);

        % 存储分区
        imagePartitions1{i, j} = partition1;
    end
end

target_PSNR = 35; % 目标 PSNR
target_MSE = (255^2) / (10^(target_PSNR / 10));
lambda_color = 3;
% 计算目标总平方误差 (TSE)
lambda = 1920 * 1080 * lambda_color;
target_TSE = target_MSE * lambda;

cumulative_TSE_T = 0; % 初始化累积的TSE_T
Y = X ; % 初始化 Y

while cumulative_TSE_T < target_TSE
    cumulative_TSE_T = 0; % 重置当前 Y 值的累积TSE_T
    
    for row = 1:numRows
        for col = 1:numCols
            % 获取当前分区及其对应的S_T分区

            partition = imagePartitions{row, col};
            partition1 = imagePartitions1{row, col};

            [row_partition, col_partition, ~] = size(partition);
            z = zeros(row_partition, col_partition);
            partition = double(partition);
            r = partition(:, :, 1);
            g = partition(:, :, 2);
            b = partition(:, :, 3);

            TSE_r = sum(sum((r > Y(row, col)) .* (r - Y(row, col)).^2 .* partition1));
            TSE_g = sum(sum((g > Y(row, col)) .* (g - Y(row, col)).^2 .* partition1));
            TSE_b = sum(sum((b > Y(row, col)) .* (b - Y(row, col)).^2 .* partition1));
            TSE_T = TSE_r + TSE_g + TSE_b;

             % 累积TSE_T值
            cumulative_TSE_T = cumulative_TSE_T + TSE_T;
        end
    end
    
    %将Y减少1
    Y = Y - 1;
    Y = max(Y, 0);
end

Idown=X-Y;
D=X-Idown;    %最终分区背光值确定
Z=zeros(1080,1920);
row1 = 0:40:1080;   
row2 = row1;
row1 = row1 +1;
col1 = 0:40:1920;   
col2 = col1;
col1 = col1 +1;
for m = 1:27
    for n = 1:48
        Z(row1(m):row2(m+1), col1(n):col2(n+1)) = D(m, n);
    end
end           %27×48背光矩阵应用到整个背光部分

%BMA平滑
w=[0.06 0.11 0.06;0.08 0.38 0.08;0.06 0.11 0.06];
E = imfilter(D, w,'conv','replicate','same');
L = imresize(E,2,'bilinear');
F = imfilter(L, w,'conv','replicate','same');
G = imresize(F,2,'bilinear');
H = imfilter(G, w,'conv','replicate','same');
I = imresize(H,[1080,1920],'bilinear');
%BMA背光平滑结果

%线性像素补偿
a=255*ones(1080,1920);
b=a./I;
R=double(img(:,:,1));
G=double(img(:,:,2));
B=double(img(:,:,3));
II(:,:,1)=R.*b;
II(:,:,2)=G.*b;
II(:,:,3)=B.*b;
II(II>255)=255;  
%溢出率计算
RR(RR<=255)=0;
GG(GG<=255)=0;
BB(BB<=255)=0;
RGB=RR+GG+BB;
OF=sum(RGB(:) > 0);
OFR=(OF/(1920 * 1080))*100;
    
%最终的调光图像
IMG(:,:,1)=II(:,:,1).*I/255;
IMG(:,:,2)=II(:,:,2).*I/255;
IMG(:,:,3)=II(:,:,3).*I/255;

img=double(img);

% 计算PSNR
mse = immse(img, IMG);
psnr = 10 * log10((255^2) / mse);

% 计算SSIM
ssim_value = ssim(img, IMG);

% 计算PPR
p0=sum(sum(a));
p1=sum(sum(Z));
PPR=(p0-p1)/p0*100;
